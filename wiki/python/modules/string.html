<html>
    <head>
        <title> 字符串操作</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <link rel="stylesheet" href="../../wiki_res/GitHub2.css">
        <link rel="stylesheet" href="../../wiki_res/prism.css">
    </head>
<body>
	<div> >> <a href="../../index.html">wiki文档中心</a>  > <a href="../index.html">python文档</a>  > <a href="index.html">python模块学习</a> </div>
    <div class="toc">
<ul>
<li><a href="#slower">S.lower()</a></li>
<li><a href="#supper">S.upper()</a></li>
<li><a href="#sswapcase">S.swapcase()</a></li>
<li><a href="#scapitalize">S.capitalize()</a></li>
<li><a href="#stringcapwordss">String.capwords(S)</a></li>
<li><a href="#stitle">S.title()</a></li>
<li><a href="#sljustwidthfillchar">S.ljust(width,[fillchar])</a></li>
<li><a href="#srjustwidthfillchar">S.rjust(width,[fillchar])</a></li>
<li><a href="#scenterwidth-fillchar">S.center(width, [fillchar])</a></li>
<li><a href="#szfillwidth">S.zfill(width)</a></li>
<li><a href="#sfindsubstr-start-end">S.find(substr, [start, [end]])</a></li>
<li><a href="#sindexsubstr-start-end">S.index(substr, [start, [end]])</a></li>
<li><a href="#srfindsubstr-start-end">S.rfind(substr, [start, [end]])</a></li>
<li><a href="#srindexsubstr-start-end">S.rindex(substr, [start, [end]])</a></li>
<li><a href="#scountsubstr-start-end">S.count(substr, [start, [end]])</a></li>
<li><a href="#sreplaceoldstr-newstr-count">S.replace(oldstr, newstr, [count])</a></li>
<li><a href="#sstripchars">S.strip([chars])</a></li>
<li><a href="#slstripchars">S.lstrip([chars])</a></li>
<li><a href="#srstripchars">S.rstrip([chars])</a></li>
<li><a href="#sexpandtabstabsize">S.expandtabs([tabsize])</a></li>
<li><a href="#ssplitsep-maxsplit">S.split([sep, [maxsplit]])</a></li>
<li><a href="#srsplitsep-maxsplit">S.rsplit([sep, [maxsplit]])</a></li>
<li><a href="#ssplitlineskeepends">S.splitlines([keepends])</a></li>
<li><a href="#sjoinseq">S.join(seq)</a></li>
<li><a href="#stringmaketransfrom-to">String.maketrans(from, to)</a></li>
<li><a href="#stranslatetabledeletechars">S.translate(table[,deletechars])</a></li>
<li><a href="#sencodeencodingerrors">S.encode([encoding,[errors]])</a></li>
<li><a href="#sdecodeencodingerrors">S.decode([encoding,[errors]])</a></li>
<li><a href="#sstartswithprefixstartend">S.startswith(prefix[,start[,end]])</a></li>
<li><a href="#sendswithsuffixstartend">S.endswith(suffix[,start[,end]])</a></li>
<li><a href="#sisalnum">S.isalnum()</a></li>
<li><a href="#sisalpha">S.isalpha()</a></li>
<li><a href="#sisdigit">S.isdigit()</a></li>
<li><a href="#sisspace">S.isspace()</a></li>
<li><a href="#sislower">S.islower()</a></li>
<li><a href="#sisupper">S.isupper()</a></li>
<li><a href="#sistitle">S.istitle()</a></li>
<li><a href="#stringatoisbase">string.atoi(s[,base])</a></li>
<li><a href="#stringatolsbase">string.atol(s[,base])</a></li>
<li><a href="#stringatofsbase">string.atof(s[,base])</a></li>
</ul>
</div>

    <blockquote>
<p><strong>强调一下：</strong><br />
字符串对象是不可改变的，任何函数改变了字符串后，都会返回一个新的字符串，原字串并没有变。<br />
变通方法：可以用S=list(S)这个函数把S变为由单个字符为成员的list，这样的话就可以使用S[3]='a'的方式改变值，然后再使用S=" ".join(S)还原成字符串。 </p>
<p>获取字符串长度为 len(S)</p>
</blockquote>
<h3 id="slower">S.lower()</h3>
<p>小写</p>
<blockquote>
<p>S为一个字符串，下同。</p>
</blockquote>
<h3 id="supper">S.upper()</h3>
<p>大写</p>
<h3 id="sswapcase">S.swapcase()</h3>
<p>大小写互换</p>
<h3 id="scapitalize">S.capitalize()</h3>
<p>首字母大写</p>
<h3 id="stringcapwordss">String.capwords(S)</h3>
<p>这是模块中的方法。它把S用split()函数分开，然后用capitalize()把首字母变成大写，最后用join()合并到一起</p>
<h3 id="stitle">S.title()</h3>
<p>只有首字母大写，其余为小写，模块中没有这个方法</p>
<h3 id="sljustwidthfillchar">S.ljust(width,[fillchar])</h3>
<p>输出width个字符，S左对齐，不足部分用fillchar填充，默认的为空格。</p>
<h3 id="srjustwidthfillchar">S.rjust(width,[fillchar])</h3>
<p>右对齐</p>
<h3 id="scenterwidth-fillchar">S.center(width, [fillchar])</h3>
<p>中间对齐</p>
<h3 id="szfillwidth">S.zfill(width)</h3>
<p>把S变成width长，并在右对齐，不足部分用0补足</p>
<h3 id="sfindsubstr-start-end">S.find(substr, [start, [end]])</h3>
<p>返回S中出现substr的第一个字母的标号，如果S中没有substr则返回-1。start和end作用就相当于在S[start:end]中搜索</p>
<h3 id="sindexsubstr-start-end">S.index(substr, [start, [end]])</h3>
<p>与find()相同，只是在S中没有substr时，会返回一个运行时错误</p>
<h3 id="srfindsubstr-start-end">S.rfind(substr, [start, [end]])</h3>
<p>返回S中最后出现的substr的第一个字母的标号，如果S中没有substr则返回-1，也就是说从右边算起的第一次出现的substr的首字母标号</p>
<h3 id="srindexsubstr-start-end">S.rindex(substr, [start, [end]])</h3>
<p>与rfind()相同，只是在S中没有substr时，会返回一个运行时错误</p>
<h3 id="scountsubstr-start-end">S.count(substr, [start, [end]])</h3>
<p>计算substr在S中出现的次数</p>
<h3 id="sreplaceoldstr-newstr-count">S.replace(oldstr, newstr, [count])</h3>
<p>把S中的oldstar替换为newstr，count为替换次数。这是替换的通用形式，还有一些函数进行特殊字符的替换</p>
<h3 id="sstripchars">S.strip([chars])</h3>
<p>把S中前后chars中有的字符全部去掉，可以理解为把S前后chars替换为None</p>
<h3 id="slstripchars">S.lstrip([chars])</h3>
<h3 id="srstripchars">S.rstrip([chars])</h3>
<h3 id="sexpandtabstabsize">S.expandtabs([tabsize])</h3>
<p>把S中的tab字符替换没空格，每个tab替换为tabsize个空格，默认是8个</p>
<h3 id="ssplitsep-maxsplit">S.split([sep, [maxsplit]])</h3>
<p>以sep为分隔符，把S分成一个list。maxsplit表示分割的次数。默认的分割符为空白字符</p>
<h3 id="srsplitsep-maxsplit">S.rsplit([sep, [maxsplit]])</h3>
<h3 id="ssplitlineskeepends">S.splitlines([keepends])</h3>
<p>把S按照行分割符分为一个list，keepends是一个bool值，如果为真每行后而会保留行分割符。</p>
<h3 id="sjoinseq">S.join(seq)</h3>
<p>把seq代表的序列──字符串序列，用S连接起来</p>
<h3 id="stringmaketransfrom-to">String.maketrans(from, to)</h3>
<p>返回一个256个字符组成的翻译表，其中from中的字符被一一对应地转换成to，所以from和to必须是等长的。</p>
<h3 id="stranslatetabledeletechars">S.translate(table[,deletechars])</h3>
<p>使用上面的函数产后的翻译表，把S进行翻译，并把deletechars中有的字符删掉。需要注意的是，如果S为unicode字符串，那么就不支持 deletechars参数，可以使用把某个字符翻译为None的方式实现相同的功能。此外还可以使用codecs模块的功能来创建更加功能强大的翻译表。</p>
<h3 id="sencodeencodingerrors">S.encode([encoding,[errors]])</h3>
<p>其中encoding可以有多种值，比如gb2312 gbk gb18030 bz2 zlib big5 bzse64等都支持。errors默认值为"strict"，意思是UnicodeError。可能的值还有'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' 和所有的通过codecs.register_error注册的值。这一部分内容涉及codecs模块，不是特明白</p>
<h3 id="sdecodeencodingerrors">S.decode([encoding,[errors]])</h3>
<p>字符串的测试函数，这一类函数在string模块中没有，这些函数返回的都是bool值</p>
<h3 id="sstartswithprefixstartend">S.startswith(prefix[,start[,end]])</h3>
<p>是否以prefix开头</p>
<h3 id="sendswithsuffixstartend">S.endswith(suffix[,start[,end]])</h3>
<p>是否以suffix结尾</p>
<h3 id="sisalnum">S.isalnum()</h3>
<p>是否全是字母和数字，并至少有一个字符</p>
<h3 id="sisalpha">S.isalpha()</h3>
<p>是否全是字母，并至少有一个字符</p>
<h3 id="sisdigit">S.isdigit()</h3>
<p>是否全是数字，并至少有一个字符</p>
<h3 id="sisspace">S.isspace()</h3>
<p>是否全是空白字符，并至少有一个字符</p>
<h3 id="sislower">S.islower()</h3>
<p>S中的字母是否全是小写</p>
<h3 id="sisupper">S.isupper()</h3>
<p>S中的字母是否便是大写</p>
<h3 id="sistitle">S.istitle()</h3>
<p>S是否是首字母大写的</p>
<h3 id="stringatoisbase">string.atoi(s[,base])</h3>
<p>base默认为10，如果为0,那么s就可以是012或0x23这种形式的字符串，如果是16那么s就只能是0x23或0X12这种形式的字符串</p>
<h3 id="stringatolsbase">string.atol(s[,base])</h3>
<p>转成long</p>
<h3 id="stringatofsbase">string.atof(s[,base])</h3>
<p>转成float</p>
    <div>Powered by cwiki</div>
    <script type="text/javascript" src="../../wiki_res/prism.js"></script>
</body>
</html>